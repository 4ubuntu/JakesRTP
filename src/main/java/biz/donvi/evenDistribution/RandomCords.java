package biz.donvi.evenDistribution;


import java.io.File;
import java.io.FileWriter;
import java.io.IOException;

import static biz.donvi.evenDistribution.TransitionMatrices.*;
import static java.lang.Math.*;

public class RandomCords {

    /**
     * Purely exists for testing. The contents of this method get rewritten often.
     */
    public static void tester() throws IOException, InterruptedException {
        int radiusMax = 1000;
        int radiusMin = 400;


        File randPointDataFile = new File("plot/random.txt");
        if (!randPointDataFile.exists()) {
            randPointDataFile.getParentFile().mkdir();
            randPointDataFile.createNewFile();
        }
        FileWriter randPointDataFileWriter = new FileWriter(randPointDataFile);

        for (int i = 0; i < 20000; i++) {
            int[] randomCord = getRandXySquare(radiusMax, radiusMin);

            randPointDataFileWriter.write(randomCord[0] + " " + randomCord[1] + '\n');
        }

        randPointDataFileWriter.close();
        Runtime.getRuntime().exec(
                "\"C:/Program Files/gnuplot/bin/wgnuplot.exe\" " +
                "--persist \"D:/Laptop/Java/JakesRTP/plot/plotShape.sh\"");
    }


    /**
     * Returns an int array of length 2, representing a random coordinate pair that is both inside the square
     * x = radiusMax * 2 and y = radiusMax * 2 centered on 0,0
     * and also NOT inside the square
     * x = radiusMin * 2 and y = radiusMin * 2 centered on 0,0
     * The points generated by this method are evenly distributed throughout the area.
     *
     * @param radiusMax The maximum that |x| or |y| will be.
     * @param radiusMin The minimum that |x| or |y| will be.
     * @return A pair of numbers, each randomly generated, that satisfy the above conditions.
     */
    public static int[] getRandXySquare(int radiusMax, int radiusMin) {
        return getRandXySquare(radiusMax, radiusMin, false, false);
    }


    /**
     * Returns an int array of length 2, representing a random coordinate pair that is both inside the square
     * x = radiusMax * 2 and y = radiusMax * 2 centered on 0,0
     * and also NOT inside the square
     * x = radiusMin * 2 and y = radiusMin * 2 centered on 0,0
     * The points generated by this method are ONLY evenly distributed throughout the area IF neither
     * favorFar nor favorNear are set to be true.
     * IF favorFar exclusively is true, the points will be distributed more towards the outside.
     * IF favorNear exclusively is true, the points will be distributed more towards the inside.
     * IF both are true, the points will be distributed more towards the average of radiusMax and radiusMin.
     * This last part was not intentionally done, but it still works regardless.
     *
     * @param radiusMax The maximum that |x| or |y| will be.
     * @param radiusMin The minimum that |x| or |y| will be.
     * @param favorFar  IF true, more points will be placed near radiusMax instead of being evenly distributed
     * @param favorNear IF true, more points will be placed near radiusMin instead of being evenly distributed
     * @return A pair of numbers, each randomly generated, that satisfy the above conditions.
     */
    public static int[] getRandXySquare(int radiusMax, int radiusMin, boolean favorFar, boolean favorNear) {
        int difference = (int) ((radiusMax - radiusMin) * random());
        if (favorNear) radiusMax -= difference;
        if (favorFar) radiusMin += difference;
        double[] randPairAtSize = new double[]{
                random() * (radiusMax - radiusMin) + radiusMin,
                random() * (radiusMax + radiusMin) - radiusMin};
        double[] result = multiplyMatrixVector(
                ROTATIONS_0_90_180_270[(int) (random() * 4)],
                randPairAtSize);
        return new int[]{
                (int) result[0],
                (int) result[1]};
    }


    /**
     * Returns an int array of length 2, representing a random coordinate
     * pair that is in a circle with the given radius.
     * The coordinates generated are evenly distributed throughout the available area.
     * This method uses a different process than the other circle-related methods,
     * this method is quicker (though not by much) and more consistent in the
     * time it takes to generate a random pair, though the time aspect does not
     * matter much at all if it is being used less one million times per second.
     *
     * @param radius The radius of the circle.
     * @return A pair of numbers representing a random point inside the circle.
     */
    public static int[] getRandXyCircle(int radius) {
        double u = random() + random();
        double r = radius * (u > 1 ? 2 - u : u);
        double theta = 2 * PI * random();
        int x = (int) (r * cos(theta));
        int y = (int) (r * sin(theta));
        return new int[]{x, y};
    }


    /**
     * Returns an int array of length 2, representing a random coordinate pair that is both
     * in a circle with the given radius radiusMax, and not in the circle with the given
     * radius radiusMin.
     * The coordinates generated are evenly distributed throughout the available area.
     *
     * @param radiusMax The maximum distance from the center of the circle that a point can be.
     * @param radiusMin The minimum distance from the center of the circle that a point can be.
     * @return A pair of numbers representing a random point inside the specific area in the circle.
     */
    public static int[] getRandXyCircle(int radiusMax, int radiusMin) {
        double a = (double) radiusMin / (double) radiusMax;
        a = pow(a, 2);
        double r = sqrt((random() * (1 - a) + a));
        double theta = 2 * PI * random();
        int x = (int) (r * cos(theta) * radiusMax);
        int y = (int) (r * sin(theta) * radiusMax);
        return new int[]{x, y};
    }


    /**
     * THIS METHOD IS FOR TESTING, AND WILL PROBABLY NEVER BE COMPLECTED.
     * Currently, it will return a random point in a triangle ABC where
     * B is at the origin, |AB| = |BC| = radiusMax, and BC is on the X axis.
     *
     * @param radiusMax Length of AB and BC
     * @param radiusMin Not currently supported
     * @return A pair of numbers representing a random point inside the triangle.
     */
    public static int[] getRandXyTriangle(int radiusMax, int radiusMin) {
//        //hehe doin some temp code here
//        int[] temp = getRandXyCircle(radiusMax,radiusMin);
//        double[] temp2 = new double[]{(double)temp[0],(double)temp[1]};
//        double[] temp3 = multiplyMatrixVector(getSquish(0.25),temp2);
//        return new int[]{(int)temp3[0],(int)temp3[1]};


        double x = random();
        double y = random();

        if (x + y > 1) {
            double c = x;
            x = 1 - y;
            y = 1 - c;
        }

        x *= radiusMax;
        y *= radiusMax;
        return new int[]{
                (int) x,
                (int) y
        };
    }
}

